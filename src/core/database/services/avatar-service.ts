import { db } from '../client'
import { avatars, users } from '../schema'
import { eq, and } from 'drizzle-orm'
import type { Avatar, NewAvatar } from '../types'
import type { AvatarCustomization } from '@/features/avatar/types'

export class AvatarService {
  // Create a new avatar
  async createAvatar(userId: string, avatarData: AvatarCustomization): Promise<Avatar> {
    const newAvatar: NewAvatar = {
      userId,
      name: avatarData.name,
      metadata: avatarData,
      isDefault: false
    }

    const result = await db.insert(avatars).values(newAvatar).returning()
    return result[0]
  }

  // Get all avatars for a user
  async getUserAvatars(userId: string): Promise<Avatar[]> {
    return await db
      .select()
      .from(avatars)
      .where(eq(avatars.userId, userId))
      .orderBy(avatars.createdAt)
  }

  // Get a specific avatar by ID
  async getAvatar(avatarId: string, userId: string): Promise<Avatar | null> {
    const result = await db
      .select()
      .from(avatars)
      .where(and(eq(avatars.id, avatarId), eq(avatars.userId, userId)))
      .limit(1)

    return result[0] || null
  }

  // Update an avatar
  async updateAvatar(
    avatarId: string, 
    userId: string, 
    updates: Partial<AvatarCustomization>
  ): Promise<Avatar | null> {
    const existingAvatar = await this.getAvatar(avatarId, userId)
    if (!existingAvatar) return null

    const updatedMetadata = {
      ...(existingAvatar.metadata as AvatarCustomization),
      ...updates
    }

    const result = await db
      .update(avatars)
      .set({
        metadata: updatedMetadata,
        updatedAt: new Date()
      })
      .where(and(eq(avatars.id, avatarId), eq(avatars.userId, userId)))
      .returning()

    return result[0] || null
  }

  // Delete an avatar
  async deleteAvatar(avatarId: string, userId: string): Promise<boolean> {
    const result = await db
      .delete(avatars)
      .where(and(eq(avatars.id, avatarId), eq(avatars.userId, userId)))
      .returning()

    return result.length > 0
  }

  // Set an avatar as default
  async setDefaultAvatar(avatarId: string, userId: string): Promise<boolean> {
    // First, remove default from all user's avatars
    await db
      .update(avatars)
      .set({ isDefault: false })
      .where(eq(avatars.userId, userId))

    // Then set the specified avatar as default
    const result = await db
      .update(avatars)
      .set({ isDefault: true })
      .where(and(eq(avatars.id, avatarId), eq(avatars.userId, userId)))
      .returning()

    return result.length > 0
  }

  // Get user's default avatar
  async getDefaultAvatar(userId: string): Promise<Avatar | null> {
    const result = await db
      .select()
      .from(avatars)
      .where(and(eq(avatars.userId, userId), eq(avatars.isDefault, true)))
      .limit(1)

    return result[0] || null
  }

  // Migrate from localStorage data
  async migrateFromLocalStorage(
    userId: string, 
    localAvatars: AvatarCustomization[]
  ): Promise<Avatar[]> {
    const migratedAvatars: Avatar[] = []

    for (const localAvatar of localAvatars) {
      try {
        const avatar = await this.createAvatar(userId, localAvatar)
        migratedAvatars.push(avatar)
      } catch (error) {
        console.error(`Failed to migrate avatar ${localAvatar.name}:`, error)
      }
    }

    return migratedAvatars
  }

  // Export user's avatars
  async exportAvatars(userId: string): Promise<string> {
    const userAvatars = await this.getUserAvatars(userId)
    return JSON.stringify({
      avatars: userAvatars.map(avatar => avatar.metadata),
      exportedAt: new Date().toISOString(),
      userId
    })
  }

  // Import avatars from export data
  async importAvatars(userId: string, exportData: string): Promise<Avatar[]> {
    try {
      const parsed = JSON.parse(exportData)
      if (parsed.avatars && Array.isArray(parsed.avatars)) {
        const importedAvatars: Avatar[] = []
        
        for (const avatarData of parsed.avatars) {
          // Generate new ID and name to avoid conflicts
          const importedData = {
            ...avatarData,
            id: undefined, // Will be generated by database
            name: `${avatarData.name} (임포트됨)`
          }
          
          try {
            const avatar = await this.createAvatar(userId, importedData)
            importedAvatars.push(avatar)
          } catch (error) {
            console.error(`Failed to import avatar ${avatarData.name}:`, error)
          }
        }
        
        return importedAvatars
      }
    } catch (error) {
      console.error('Failed to parse import data:', error)
    }
    
    return []
  }
}